https://school.programmers.co.kr/learn/courses/30/lessons/258711

## 첫 제출

``` java
테스트 35 〉	실패 (0.16ms, 86.8MB)
```

테스트 케이스 한개만 틀렸다.
탐색을 안하고 풀었는데, 정점마다 입력 개수와 출력 개수를 계산해서 작성했다.
도넛모양은 입력, 출력이 전부 1인데 다른 그래프에서도 그런 경우가 많아서, 처음에 주는 모든 그래프에 이어진 정점에서 출력 개수가 그래프의 총 개수임을 이용하여 역추론했다.
막대그래프는 출력 0 입력 1 인 정점의 개수, 8자 그래프는 출력 2 입력 2 인 정점의 개수로 추론했다.
35개 중 34개는 통과한 걸 보아 로직은 틀리지 않는데, 예외처리에서 문제가 있는 것 같다.

## 개선 1

이어진 값이 아닌 경우.
``` java
입력값 〉	[[30, 1], [30, 4], [1, 2], [4, 5], [5, 4]]
기댓값 〉	[30, 1, 1, 0]
```
와 같이 띄엄띄엄 숫자가 들어오는 경우를 고려해서 갈 수 있는 정점을 찾는 코드를 추가로 작성했다.

``` java
테스트 14 〉	통과 (964.74ms, 383MB)
테스트 35 〉	통과 (0.18ms, 84.7MB)
```
통과하기는 했으나, 동작하게만 코드를 작성해서 N번 탐색을 너무 많이해서 아슬아슬한 코드가 되었다.

## 성능 개선

``` java
테스트 14 〉	통과 (87.92ms, 195MB)
```

N번 탐색을 한번에 처리하고, HashMap대신 배열로 작성했다.
HashMap을 사용한 이유가 정적배열로 10만개 생성하고 싶지 않아서 그랬던건데, 시간복잡도와 메모리 전부 손해를 봐서 아쉬운 코딩이 되었다.
